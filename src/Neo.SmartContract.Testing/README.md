# Neo.SmartContract.Testing

The **Neo.SmartContract.Testing** project is designed to facilitate the development of unit tests for smart contract developers in neo, it does not require the project to be done in C#, as it is possible to export artifacts from an `Abi`.

## Table of Contents

- [Installation and configuration](#installation-and-configuration)
    - [Generating Artifacts](#generating-artifacts)
        - [Example of use](#example-of-use)
- [TestEngine](#testengine)
    - [Properties](#properties)
    - [Methods](#methods)
    - [Example of use](#example-of-use)
- [NativeArtifacts](#nativeartifacts)
    - [Methods](#methods)
    - [Example of use](#example-of-use)
- [SmartContractStorage](#smartcontractstorage)
    - [Methods](#methods)
    - [Example of use](#example-of-use)
- [Custom mocks](#custom-mocks)
    - [Example of use](#example-of-use)
- [Forging signatures](#forging-signatures)
    - [Example of use](#example-of-use)
- [Event testing](#event-testing)
    - [Example of use](#example-of-use)

### Installation and configuration

#### Generating Artifacts

The process of generating the artifacts, or the source code necessary to interact with the contract, is extremely simple. There are two main ways to do it:

1. Using the `ABI` of a contract, the necessary source code to interact with the contract can be generated by calling the `GetArtifactsSource` method available in the `Neo.SmartContract.Testing.Extensions` namespace, we will only have to specify the name of our resulting class, which will usually be the same as the one existing in the `Name` field of the manifest.

2. Through the Neo C# compiler, automatically when compiling a contract in C#, the necessary source code to interact with the contract is generated. This is available in the same path as the generated .nef file, and its extension are `.artifacts.cs` and `.artifacts.dll`.

##### Example of use

```csharp
[TestClass]
public class MyUnitTestClass
{
    [TestMethod]
    public void GenerateNativeArtifacts()
    {
        foreach (var n in Native.NativeContract.Contracts)
        {
            var manifest = n.Manifest;
            var source = manifest.Abi.GetArtifactsSource(manifest.Name);

            File.WriteAllText($"{manifest.Name}.cs", source);
        }
    }
}
```

### TestEngine

The `TestEngine` class is the main class of the library, providing a simple and intuitive interface for testing smart contracts.

#### Properties

The publicly exposed read-only properties are as follows:

- **ProtocolSettings**: Assigned during the construction of the `TestEngine` and defines the configuration values of the test environment. It defaults to the current blockchain protocol.
- **Sender**: Returns the script hash of the transaction sender, which corresponds to the first `Signer` defined in the `Transaction` object.
- **Native**: Allows access to the native contracts, and their state. It facilitates access to the chain's native contracts through some precompiled artifacts. This point is further detailed in [NativeArtifacts](#nativeartifacts).
- **ValidatorsAddress**: Defines the address for the validators of the defined *ProtocolSettings*.
- **CommitteeAddress**: Returns the address of the current chain's committee.
- **Transaction**: Defines the transaction that will be used as `ScriptContainer` for the neo virtual machine, by default it updates the script of the same as calls are composed and executed, and the `Signers` will be used as validators for the `CheckWitness`, regardless of whether the signature is correct or not, so if you want to test with different wallets or scopes, you do not need to sign the transaction correctly, just set the desired signers.
- **CurrentBlock**: Defaults to `Genesis` for the defined `ProtocolSettings`, but the height has been incremented by 1 to avoid issues related to the generation of gas from native contracts.

For initialize, we have:

- **Storage**: Abstracts access to storage, allowing for easy `Snapshots` as well as reverting them. It can only be set during the initialization of the class, and allows access to the storage of contracts, as well as manually altering their state.

And for read and write, we have:

- **Gas**: Sets the gas execution limit for contract calls.

#### Methods

It has three methods:

- **Execute(script)**: Executes a script on the neo virtual machine and returns the execution result.
- **Deploy(nef, manifest, data, customMock)**: Deploys the smart contract by calling the native method `ContractManagement.deploy`. It allows setting [custom mocks](#custom-mocks), which will be detailed later. And returns the instance of the contract that has been deployed.
- **FromHash(hash, customMocks, checkExistence)**: Creates an instance without needing a `NefFile` or `Manifest`, only requiring the contract's hash. It does not consider whether the contract exists on the chain unless `checkExistence` is set to `true`.

#### Example of use

```csharp
// Create the engine initializing the native contracts

var engine = new TestEngine(true);

// Instantiate neo contract from native hash, (not necessary if we use engine.Native.NEO)

var neo = engine.FromHash<NeoToken>(engine.Native.NEO.Hash, false);

// Ensure that the main address contains the totalSupply

Assert.AreEqual(100_000_000, neo.TotalSupply);
Assert.AreEqual(neo.TotalSupply, neo.BalanceOf(engine.BFTAddress));
```

### NativeArtifacts

This class provides precompiled artifacts for neo's native contracts, thereby simplifying and facilitating calls to native contracts.

#### Methods

It has only one method:

- **Initialize(bool commit = false)**: Initializes the native contract with the necessary parameters for its operation. It's important to note that this step must usually be performed, or deploying contracts won't be possible. However, if using a `Storage` that already contains chain data and these contracts have been initialized, calling this method should be avoided. The `commit` argument determines whether to commit to the active `Snapshot` of the `TestStorage` (default is `false`).

#### Example of use

```csharp
// Create the engine initializing the native contracts

var engine = new TestEngine(true);

// Ensure that the main address contains the totalSupply

Assert.AreEqual(100_000_000, engine.Native.NEO.TotalSupply);
Assert.AreEqual(engine.Native.NEO.TotalSupply, engine.Native.NEO.BalanceOf(engine.BFTAddress));
```

### SmartContractStorage

Avoids dealing with prefixes foreign to the internal behavior of the storage, focusing the developer solely on accessing the storage of the contract, just as it is managed by the smart contract itself, allowing reading, injecting, and deleting entries of the contract in question.

#### Methods

Mainly exposes the methods `Contains`, `Get`, `Put`, and `Remove`, all of them responsible for reading and manipulating the contract's information.

#### Example of use

```csharp
// Defines the prefix used to store the registration price in neo

byte[] registerPricePrefix = new byte[] { 13 };

// Create engine and initialize native contracts

TestEngine engine = new(true);

// Check previous data

Assert.AreEqual(100000000000, engine.Native.NEO.RegisterPrice);

// Alter data

engine.Native.NEO.Storage.Put(registerPricePrefix, BigInteger.MinusOne);

// Check altered data

Assert.AreEqual(BigInteger.MinusOne, engine.Native.NEO.RegisterPrice);
```

### Custom mocks

Custom mocks allow redirecting certain calls to smart contracts so that instead of calling the underlying contract, the logic is redirected to a method in .NET, allowing the developer to test in complex environments without significant issues.

Imagine that our project checks that our account has a balance of 123 NEO. It would be enough to redirect the calls to the NEO `balanceOf` method in the following way, so that it always returns 123.

It's important to note that all syscalls going to this contract will also be redirected, not only the calls to the method in .NET.


#### Example of use

```csharp
// Initialize TestEngine and native smart contracts

TestEngine engine = new(true);

// Get neo token smart contract and mock balanceOf to always return 123

var neo = engine.FromHash<NeoToken>(engine.Native.NEO.Hash,
    mock => mock.Setup(o => o.BalanceOf(It.IsAny<UInt160>())).Returns(123),
    false);

// Test direct call

Assert.AreEqual(123, neo.BalanceOf(engine.BFTAddress));

// Test vm call

using (ScriptBuilder script = new())
{
    script.EmitDynamicCall(neo.Hash, nameof(neo.BalanceOf), engine.BFTAddress);

    Assert.AreEqual(123, engine.Execute(script.ToArray()).GetInteger());
}
```

### Forging signatures

To fake signatures and allow testing our contracts in authorized and unauthorized environments, it's enough to replace the signers of the `Transaction` object in our `TestEngine`. This way, we can simulate the signatures of other users. It's worth noting that it's not necessary to modify the `Witnesses` since it's not checked whether the transaction is well-formed.

#### Example of use

```csharp
// Initialize out TestEngine

var engine = new TestEngine(true);

// Check initial value of getRegisterPrice

Assert.AreEqual(100000000000, engine.Native.NEO.RegisterPrice);

// Fake Committee Signature

engine.Transaction.Signers = new Network.P2P.Payloads.Signer[]
{
    new Network.P2P.Payloads.Signer()
    {
            Account = engine.CommitteeAddress,
            Scopes = Network.P2P.Payloads.WitnessScope.Global
    }
};

// Change RegisterPrice to 123

engine.Native.NEO.RegisterPrice = 123;

Assert.AreEqual(123, engine.Native.NEO.RegisterPrice);

// Now test it without this signature

engine.Transaction.Signers[0].Scopes = Network.P2P.Payloads.WitnessScope.None;

Assert.ThrowsException<TargetInvocationException>(() => engine.Native.NEO.RegisterPrice = 123);
```

### Event testing

Testing that our events have been triggered has never been so easy. Simply when a contract notification is launched, the corresponding event will be invoked, making it easier to capture and detect.

#### Example of use

```csharp
// Create and initialize TestEngine

var engine = new TestEngine(true);

// Fake signature of BFTAddress

engine.Transaction.Signers = new Network.P2P.Payloads.Signer[]
{
    new Network.P2P.Payloads.Signer()
    {
            Account = engine.BFTAddress,
            Scopes = Network.P2P.Payloads.WitnessScope.Global
    }
};

// Attach to Transfer event

var raisedEvent = false;

engine.Native.NEO.OnTransfer += (UInt160 from, UInt160 to, BigInteger amount) =>
{
    // If the event is raised, the variable will be changed
    raisedEvent = true;
};

// Define address to transfer funds

UInt160 addressTo = UInt160.Parse("0x1230000000000000000000000000000000000000");

Assert.AreEqual(0, engine.Native.NEO.BalanceOf(addressTo));

// Transfer funds

Assert.IsTrue(engine.Native.NEO.Transfer(engine.Transaction.Sender, addressTo, 123, null));

// Ensure that we have balance and the event was raised

Assert.IsTrue(raisedEvent);
Assert.AreEqual(123, engine.Native.NEO.BalanceOf(addressTo));
```
