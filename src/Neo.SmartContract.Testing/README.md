# Neo.SmartContract.Testing

The **Neo.SmartContract.Testing** project is designed to facilitate the development of unit tests for smart contract developers in neo, it does not require the project to be done in C#, as it is possible to export artifacts from a `NefFile`.

## Table of Contents

- [Installation and configuration](#installation-and-configuration)
    - [Generating Artifacts](#generating-artifacts)
        - [Example of use](#example-of-use)
- [TestEngine](#testengine)
    - [Properties](#properties)
    - [Methods](#methods)
    - [Example of use](#example-of-use)
- [NativeArtifacts](#nativeartifacts)
    - [Methods](#methods)
    - [Example of use](#example-of-use)
- [SmartContractStorage](#smartcontractstorage)
    - [Methods](#methods)
    - [Example of use](#example-of-use)
- [Custom mocks](#custom-mocks)
    - [Example of use](#example-of-use)
- [Forging signatures](#forging-signatures)
    - [Example of use](#example-of-use)

### Installation and configuration

#### Generating Artifacts

The process of generating the artifacts, or the source code necessary to interact with the contract, is extremely simple. There are two main ways to do it:

1. Using the `ABI` of a contract, the necessary source code to interact with the contract can be generated by calling the `GetArtifactsSource` method available in the `Neo.SmartContract.Testing.Extensions` namespace, we will only have to specify the name of our resulting class, which will usually be the same as the one existing in the `Name` field of the manifest.

2. Through the Neo C# compiler, automatically when compiling a contract in C#, the necessary source code to interact with the contract is generated. This is available in the same path as the generated .nef file, and its

##### Example of use

```csharp
[TestClass]
public class MyUnitTestClass
{
    [TestMethod]
    public void GenerateNativeArtifacts()
    {
        foreach (var n in Native.NativeContract.Contracts)
        {
            var manifest = n.Manifest;
            var source = manifest.Abi.GetArtifactsSource(manifest.Name);

            File.WriteAllText($"{manifest.Name}.cs", source);
        }
    }
}
```

### TestEngine

The `TestEngine` class is the main class of the library, providing a simple and intuitive interface for testing smart contracts.

#### Properties

The publicly exposed read-only properties are as follows:

- **ProtocolSettings**: Assigned during the construction of the `TestEngine` and defines the configuration values of the test environment. It defaults to the current blockchain protocol.
- **Sender**: Returns the script hash of the transaction sender, which corresponds to the first `Signer` defined in the `Transaction` object.
- **Native**: Allows access to the native contracts, and their state. It facilitates access to the chain's native contracts through some precompiled artifacts. This point is further detailed in [NativeArtifacts](#nativeartifacts).
- **BFTAddress**: Defines the address for the validators of the defined *ProtocolSettings*.

For read and write, we have:

- **Gas**: Sets the gas execution limit for contract calls.
- **CurrentBlock**: Defaults to `Genesis` for the defined `ProtocolSettings`, but the height has been incremented by 1 to avoid issues related to the generation of gas from native contracts.
- **Transaction**: Defines the transaction that will be used as `ScriptContainer` for the neo virtual machine, by default it updates the script of the same as calls are composed and executed, and the `Signers` will be used as validators for the `CheckWitness`, regardless of whether the signature is correct or not, so if you want to test with different wallets or scopes, you do not need to sign the transaction correctly, just set the desired signers.
- **Storage**: Abstracts access to storage, allowing for easy `Snapshots` as well as reverting them. It can only be set during the initialization of the class, and allows access to the storage of contracts, as well as manually altering their state.

#### Methods

It has two main methods:

- **Execute(script)**: Executes a script on the neo virtual machine and returns the execution result.
- **Deploy(nef, manifest, data, customMock)**: Deploys the smart contract by calling the native method `ContractManagement.deploy`. It allows setting [custom mocks](#custom-mocks), which will be detailed later. And returns the instance of the contract that has been deployed.
- **FromHash(hash, customMocks, checkExistence)**: Creates an instance without needing a `NefFile` or `Manifest`, only requiring the contract's hash. It does not consider whether the contract exists on the chain unless `checkExistence` is set to `true`.

#### Example of use

```csharp
// Create the engine initializing the native contracts

var engine = new TestEngine(true);

// Instantiate neo contract from native hash, (not necessary if we use engine.Native.NEO)

var neo = engine.FromHash<NeoToken>(engine.Native.NEO.Hash, false);

// Ensure that the main address contains the totalSupply

Assert.AreEqual(100_000_000, neo.totalSupply());
Assert.AreEqual(neo.totalSupply(), neo.balanceOf(engine.BFTAddress));
```

### NativeArtifacts

This class provides precompiled artifacts for neo's native contracts, thereby simplifying and facilitating calls to native contracts.

#### Methods

It has two main methods:

- **GetCommitteeAddress()**: Returns the address of the current chain's committee.
- **Initialize(bool commit = false)**: Initializes the native contract with the necessary parameters for its operation. It's important to note that this step must usually be performed, or deploying contracts won't be possible. However, if using a `Storage` that already contains chain data and these contracts have been initialized,

#### Example of use

```csharp
// Create the engine initializing the native contracts

var engine = new TestEngine(true);

// Ensure that the main address contains the totalSupply

Assert.AreEqual(100_000_000, engine.Native.NEO.totalSupply());
Assert.AreEqual(engine.Native.NEO.totalSupply(), engine.Native.NEO.balanceOf(engine.BFTAddress));
```

### SmartContractStorage

Avoids dealing with prefixes foreign to the internal behavior of the storage, focusing the developer solely on accessing the storage of the contract in question, just as it is managed by the smart contract itself, allowing reading, injecting, and deleting entries of the contract in question.

#### Methods

Mainly exposes the methods `Read`, `Put`, and `Remove`, all of them responsible for reading and manipulating the contract's information.

#### Example of use

```csharp
// Defines the prefix used to store the registration price in neo

const byte Prefix_RegisterPrice = 13;

// Engine an contract creation

TestEngine engine = new(true);

// Check previous data

Assert.AreEqual(100000000000, engine.Native.NEO.getRegisterPrice());

// Alter data

engine.Native.NEO.Storage.Put(new byte[] { Prefix_RegisterPrice }, BigInteger.MinusOne.ToByteArray());

// Check altered data

Assert.AreEqual(BigInteger.MinusOne, engine.Native.NEO.getRegisterPrice());
```

### Custom mocks

Custom mocks allow redirecting certain calls to smart contracts so that instead of calling the underlying contract, the logic is redirected to a method in .NET, allowing the developer to test in complex environments without significant issues.

Imagine that our project checks that our account has a balance of 123 NEO. It would be enough to redirect the calls to the NEO `balanceOf` method in the following way, so that it always returns 123.

It's important to note that all syscalls going to the contract in question will also be redirected, not only the calls to the method in .NET.


#### Example of use

```csharp
// Initialize TestEngine and native smart contracts

TestEngine engine = new(true);

// Get neo token smart contract and mock balanceOf to always return 123

var neo = engine.FromHash<NeoToken>(engine.Native.NEO.Hash,
    mock => mock.Setup(o => o.balanceOf(It.IsAny<UInt160>())).Returns(123),
    false);

// Test direct call

Assert.AreEqual(123, neo.balanceOf(engine.BFTAddress));

// Test vm call

using (ScriptBuilder script = new())
{
    script.EmitDynamicCall(neo.Hash, nameof(neo.balanceOf), engine.BFTAddress);

    Assert.AreEqual(123, engine.Execute(script.ToArray()).GetInteger());
}
```

### Forging signatures

To fake signatures and allow testing our contracts in authorized and unauthorized environments, it's enough to replace the signers of the `Transaction` object in our `TestEngine`. This way, we can simulate the signatures of other users. It's worth noting that it's not necessary to modify the `Witnesses` since it's not checked whether the transaction is well-formed.

#### Example of use

```csharp
// Initialize out TestEngine

var engine = new TestEngine(true);

// Check initial value of getRegisterPrice

Assert.AreEqual(100000000000, engine.Native.NEO.getRegisterPrice());

// Fake Committee Signature

engine.Transaction.Signers = new Network.P2P.Payloads.Signer[]
{
    new Network.P2P.Payloads.Signer()
    {
         Account = engine.Native.GetCommitteeAddress(),
         Scopes = Network.P2P.Payloads.WitnessScope.Global
    }
};

// Change RegisterPrice to 123

engine.Native.NEO.setRegisterPrice(123);

Assert.AreEqual(123, engine.Native.NEO.getRegisterPrice());

// Now test it without this signature

engine.Transaction.Signers[0].Scopes = Network.P2P.Payloads.WitnessScope.None;

Assert.ThrowsException<TargetInvocationException>(() => engine.Native.NEO.setRegisterPrice(123));
```
