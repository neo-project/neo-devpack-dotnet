using Neo.SmartContract.Fuzzer.Extensions;
using Neo.SmartContract.Fuzzer.Reporting;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Neo.SmartContract.Fuzzer.Detectors
{
    /// <summary>
    /// Base class for detectors that analyze execution results.
    /// </summary>
    public abstract class ExecutionVulnerabilityDetector
    {
        /// <summary>
        /// Gets the name of the detector.
        /// </summary>
        public abstract string Name { get; }

        /// <summary>
        /// Gets the description of the detector.
        /// </summary>
        public abstract string Description { get; }

        /// <summary>
        /// Detects vulnerabilities in an execution result.
        /// </summary>
        /// <param name="testCase">The test case that was executed.</param>
        /// <param name="result">The execution result.</param>
        /// <returns>A list of issue reports for any vulnerabilities found.</returns>
        public abstract List<IssueReport> DetectVulnerabilities(TestCase testCase, ExecutionResult result);
    }

    /// <summary>
    /// Detects crashes (VM faults or exceptions) during execution.
    /// </summary>
    public class CrashDetector : ExecutionVulnerabilityDetector
    {
        /// <inheritdoc/>
        public override string Name => "Crash Detector";

        /// <inheritdoc/>
        public override string Description => "Detects crashes (VM faults or exceptions) during execution.";

        /// <inheritdoc/>
        public override List<IssueReport> DetectVulnerabilities(TestCase testCase, ExecutionResult result)
        {
            var issues = new List<IssueReport>();

            if (!result.Success)
            {
                var issue = IssueReport.FromExecutionResult(
                    testCase,
                    result,
                    "Crash",
                    IssueSeverity.High,
                    $"The contract crashed during execution of method {testCase.MethodName}.");

                if (result.Exception != null)
                {
                    issue.Remediation = $"Fix the code that causes the exception: {result.Exception.Message}";
                }

                issues.Add(issue);
            }

            return issues;
        }
    }

    /// <summary>
    /// Detects high gas consumption during execution.
    /// </summary>
    public class GasConsumptionDetector : ExecutionVulnerabilityDetector
    {
        private readonly long _gasThreshold;

        /// <summary>
        /// Initializes a new instance of the <see cref="GasConsumptionDetector"/> class.
        /// </summary>
        /// <param name="gasThreshold">The gas threshold above which to report an issue.</param>
        public GasConsumptionDetector(long gasThreshold)
        {
            _gasThreshold = gasThreshold;
        }

        /// <inheritdoc/>
        public override string Name => "Gas Consumption Detector";

        /// <inheritdoc/>
        public override string Description => $"Detects high gas consumption (above {_gasThreshold}) during execution.";

        /// <inheritdoc/>
        public override List<IssueReport> DetectVulnerabilities(TestCase testCase, ExecutionResult result)
        {
            var issues = new List<IssueReport>();

            if (result.FeeConsumed > _gasThreshold)
            {
                var issue = IssueReport.FromExecutionResult(
                    testCase,
                    result,
                    "High Gas Consumption",
                    IssueSeverity.Medium,
                    $"The contract consumed {result.FeeConsumed} gas during execution of method {testCase.MethodName}, which is above the threshold of {_gasThreshold}.");

                issue.Remediation = "Optimize the code to reduce gas consumption. Look for loops, complex calculations, or large storage operations.";

                issues.Add(issue);
            }

            return issues;
        }
    }

    /// <summary>
    /// Detects storage-related vulnerabilities.
    /// </summary>
    public class StorageVulnerabilityDetector : ExecutionVulnerabilityDetector
    {
        /// <inheritdoc/>
        public override string Name => "Storage Vulnerability Detector";

        /// <inheritdoc/>
        public override string Description => "Detects storage-related vulnerabilities such as large keys or values.";

        /// <inheritdoc/>
        public override List<IssueReport> DetectVulnerabilities(TestCase testCase, ExecutionResult result)
        {
            var issues = new List<IssueReport>();

            if (result.StorageChanges != null && result.StorageChanges.Count > 0)
            {
                // Check for large keys
                foreach (var key in result.StorageChanges.Keys)
                {
                    if (key.Length > 64)
                    {
                        var issue = IssueReport.FromExecutionResult(
                            testCase,
                            result,
                            "Large Storage Key",
                            IssueSeverity.Medium,
                            $"The contract used a large storage key ({key.Length} bytes) during execution of method {testCase.MethodName}.");

                        issue.Remediation = "Use smaller storage keys to reduce gas consumption. Consider using a hash of the data instead of the full data as a key.";

                        issues.Add(issue);
                    }
                }

                // Check for large values
                foreach (var value in result.StorageChanges.Values)
                {
                    if (value.Length > 1024)
                    {
                        var issue = IssueReport.FromExecutionResult(
                            testCase,
                            result,
                            "Large Storage Value",
                            IssueSeverity.Medium,
                            $"The contract stored a large value ({value.Length} bytes) during execution of method {testCase.MethodName}.");

                        issue.Remediation = "Use smaller storage values to reduce gas consumption. Consider splitting large data into multiple storage entries or using a different storage strategy.";

                        issues.Add(issue);
                    }
                }

                // Check for many storage operations
                if (result.StorageChanges.Count > 10)
                {
                    var issue = IssueReport.FromExecutionResult(
                        testCase,
                        result,
                        "Many Storage Operations",
                        IssueSeverity.Low,
                        $"The contract performed {result.StorageChanges.Count} storage operations during execution of method {testCase.MethodName}.");

                    issue.Remediation = "Reduce the number of storage operations to improve performance and reduce gas consumption.";

                    issues.Add(issue);
                }
            }

            return issues;
        }
    }

    /// <summary>
    /// Detects integer-related vulnerabilities.
    /// </summary>
    public class IntegerVulnerabilityDetector : ExecutionVulnerabilityDetector
    {
        /// <inheritdoc/>
        public override string Name => "Integer Vulnerability Detector";

        /// <inheritdoc/>
        public override string Description => "Detects integer-related vulnerabilities such as overflow and division by zero.";

        /// <inheritdoc/>
        public override List<IssueReport> DetectVulnerabilities(TestCase testCase, ExecutionResult result)
        {
            var issues = new List<IssueReport>();

            if (!result.Success && result.Exception != null)
            {
                // Check for division by zero
                if (result.Exception.Message.Contains("division by zero") ||
                    result.Exception.Message.Contains("DivideByZeroException"))
                {
                    var issue = IssueReport.FromExecutionResult(
                        testCase,
                        result,
                        "Division by Zero",
                        IssueSeverity.High,
                        $"The contract attempted to divide by zero during execution of method {testCase.MethodName}.");

                    issue.Remediation = "Add checks to ensure that divisors are not zero before performing division operations.";

                    issues.Add(issue);
                }

                // Check for overflow
                if (result.Exception.Message.Contains("overflow") ||
                    result.Exception.Message.Contains("OverflowException"))
                {
                    var issue = IssueReport.FromExecutionResult(
                        testCase,
                        result,
                        "Integer Overflow",
                        IssueSeverity.High,
                        $"The contract experienced an integer overflow during execution of method {testCase.MethodName}.");

                    issue.Remediation = "Use checked arithmetic or add bounds checks to prevent integer overflow.";

                    issues.Add(issue);
                }
            }

            return issues;
        }
    }
}
