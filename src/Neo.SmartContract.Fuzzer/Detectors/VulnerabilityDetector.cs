using Neo.SmartContract.Fuzzer.SymbolicExecution;
using Neo.VM;
using Neo.SmartContract.Fuzzer.SymbolicExecution.Types;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Neo.SmartContract.Fuzzer.Detectors
{
    /// <summary>
    /// Main coordinator for vulnerability detection in Neo N3 smart contracts.
    /// Orchestrates multiple specialized detectors to identify various vulnerability types.
    /// </summary>
    public class VulnerabilityDetector
    {
        private readonly List<IVulnerabilityDetector> _detectors;

        /// <summary>
        /// Creates a new VulnerabilityDetector with default detectors.
        /// </summary>
        public VulnerabilityDetector()
        {
            _detectors = new List<IVulnerabilityDetector>
            {
                new AbortDetector(),
                new IntegerOverflowDetector(),
                new ReentrancyDetector(),
                new UnauthorizedAccessDetector(),
                new StorageManipulationDetector(),
                new NeoNativeContractDetector(),
                new OracleVulnerabilityDetector(),
                new TokenImplementationDetector()
            };
        }

        /// <summary>
        /// Creates a new VulnerabilityDetector with the specified detectors.
        /// </summary>
        /// <param name="detectors">List of vulnerability detectors to use.</param>
        public VulnerabilityDetector(IEnumerable<IVulnerabilityDetector> detectors)
        {
            _detectors = detectors.ToList();
        }

        /// <summary>
        /// Analyzes the result of symbolic execution to detect potential vulnerabilities.
        /// </summary>
        /// <param name="result">The result of symbolic execution containing all execution paths.</param>
        /// <returns>A list of all detected vulnerabilities across all execution paths.</returns>
        public List<VulnerabilityRecord> DetectVulnerabilities(SymbolicExecutionResult result)
        {
            var vulnerabilities = new List<VulnerabilityRecord>();

            // Process each execution path
            foreach (var path in result.ExecutionPaths)
            {
                // Apply all detectors to the final state of this path
                foreach (var detector in _detectors)
                {
                    // Extract useful information from the final state of the execution path
                    // Since we don't have direct access to the final SymbolicState object,
                    // we create a new one with information from the path
                    var finalState = CreateFinalStateFromPath(path);
                    var detected = detector.Detect(finalState, path.HaltReason);
                    vulnerabilities.AddRange(detected);
                }
            }

            return vulnerabilities;
        }

        /// <summary>
        /// Registers an additional vulnerability detector.
        /// </summary>
        /// <param name="detector">The detector to register.</param>
        public void RegisterDetector(IVulnerabilityDetector detector)
        {
            _detectors.Add(detector);
        }

        /// <summary>
        /// Creates a SymbolicState object with information extracted from an ExecutionPath.
        /// This is used when we need to analyze the final state but don't have direct access to it.
        /// </summary>
        /// <param name="path">The execution path to extract state information from.</param>
        /// <returns>A new SymbolicState with information from the path.</returns>
        private SymbolicState CreateFinalStateFromPath(ExecutionPath path)
        {
            // Create a new state with basic information from the path
            // This is a simplified representation of the final state
            var finalStep = path.Steps.LastOrDefault();
            var script = new byte[0]; // We don't have access to the original script here

            var state = new SymbolicState(
                new System.ReadOnlyMemory<byte>(script),
                path.FinalInstructionPointer
            );

            // Set the halt reason
            state.HaltReason = path.HaltReason;
            state.IsHalted = true;

            // Add the path constraints
            foreach (var constraint in path.PathConstraints)
            {
                state.AddConstraint(constraint);
            }

            // Add execution steps
            foreach (var step in path.Steps)
            {
                state.AddExecutionStep(step);
            }

            return state;
        }
    }
}
