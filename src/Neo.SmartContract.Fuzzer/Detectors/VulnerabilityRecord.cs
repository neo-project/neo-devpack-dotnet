using System.Collections.Generic;
using Neo.SmartContract.Fuzzer.SymbolicExecution.Types;

namespace Neo.SmartContract.Fuzzer.Detectors
{
    /// <summary>
    /// Represents a potential vulnerability detected during symbolic execution.
    /// </summary>
    public class VulnerabilityRecord
    {
        /// <summary>
        /// Type or category of the vulnerability (e.g., "IntegerOverflow", "Reentrancy", "UnhandledException").
        /// </summary>
        public string Type { get; }

        /// <summary>
        /// A description of the detected vulnerability and the conditions under which it occurs.
        /// </summary>
        public string Description { get; }

        /// <summary>
        /// The final symbolic state where the vulnerability was detected.
        /// </summary>
        public Neo.SmartContract.Fuzzer.SymbolicExecution.Types.SymbolicState TriggeringState { get; }

        /// <summary>
        /// Optional: Specific instruction address or context related to the vulnerability.
        /// </summary>
        public int? InstructionPointer { get; set; }

        public VulnerabilityRecord(string type, string description, Neo.SmartContract.Fuzzer.SymbolicExecution.Types.SymbolicState triggeringState, int? instructionPointer = null)
        {
            Type = type;
            Description = description;
            TriggeringState = triggeringState;
            InstructionPointer = instructionPointer;
        }

        public override string ToString()
        {
            string ipInfo = InstructionPointer.HasValue ? $" at IP: {InstructionPointer.Value}" : "";
            return $"[{Type}] {Description}{ipInfo}\nConstraints: [{string.Join(" && ", TriggeringState.PathConstraints)}]";
        }
    }
}
