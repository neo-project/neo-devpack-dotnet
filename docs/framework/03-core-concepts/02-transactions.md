# Transactions

Transactions are the fundamental way users interact with the Neo blockchain. They are cryptographically signed data packages that instruct the network to perform actions, such as transferring assets or invoking smart contracts. Understanding their structure, especially the authorization mechanism, is key.

## Transaction Structure (Neo N3)

A typical Neo N3 transaction (`Neo.Network.P2P.Payloads.Transaction`) includes several key fields:

*   **`Version`**: Transaction format version (currently 0 for N3).
*   **`Nonce`**: A random number generated by the sender, unique to this transaction for a given sender and network. Prevents replay attacks.
*   **`SystemFee`**: GAS paid to the network for processing workload (CPU time, storage usage). This fee is burned.
*   **`NetworkFee`**: GAS paid to the consensus nodes for including the transaction in a block. This fee rewards the nodes.
*   **`ValidUntilBlock`**: The transaction is only valid up to (and including) this block height. Prevents transactions from remaining pending indefinitely. Senders calculate this based on the current block height plus an offset (e.g., `currentHeight + 100`).
*   **`Signers`**: An array defining **who needs to authorize** this transaction and the **scope** of their authorization. This declares *intent*. (Detailed below).
*   **`Attributes`**: An array for optional extra data. Can include remarks, oracle response identifiers, or other application-specific data.
*   **`Script`**: The NeoVM bytecode to be executed when the transaction is processed (e.g., a script calling `Contract.Call` to invoke a smart contract method).
*   **`Witnesses`**: An array containing the **proof of authorization** corresponding to each `Signer`. (Detailed below).

## Signers: Declaring Authorization Intent

The `Signers` array lists one or more accounts (or contracts acting as accounts) that must authorize the transaction for it to be valid under certain conditions. Each `Signer` object has:

*   **`Account` (`UInt160`)**: The script hash (address) of the account providing authorization.
*   **`Scopes` (`WitnessScope` enum)**: Defines *how broadly* the signature associated with this signer is valid within the execution context. This prevents a signature from being misused to authorize unintended actions. Key scopes include:
    *   **`None` (0)**: Not allowed. Must specify a scope.
    *   **`CalledByEntry` (1)**: (Most common for user invocations) The signature is valid **only if** the `Account` matches the initial contract being invoked (the `EntryScriptHash` in the `Runtime` context). This means the user directly called the contract specified in the transaction's script. The signature cannot authorize actions initiated by *other* contracts called subsequently within the same transaction.
    *   **`CustomContracts` (16)**: The signature is valid only when calling specific contract script hashes listed in the `AllowedContracts` field of the Signer object.
    *   **`CustomGroups` (32)**: The signature is valid only when calling contracts belonging to specific public key groups listed in the `AllowedGroups` field (using groups defined by `[ContractGroup]` attribute - less common).
    *   **`Global` (128)**: The signature is valid for the entire transaction, regardless of which contract is executing or being called. **Use with extreme caution**, as this grants broad authority. Often used by system transactions or when an account needs to authorize actions across multiple contract calls within a single transaction (e.g., withdrawing from Contract A and depositing into Contract B).
*   **`AllowedContracts` (`UInt160[]`)**: Used only when `Scopes` includes `CustomContracts`. Lists the script hashes this signature authorizes calls to.
*   **`AllowedGroups` (`ECPoint[]`)**: Used only when `Scopes` includes `CustomGroups`. Lists the public keys defining groups this signature authorizes calls to.

By adding a `Signer` entry, the transaction creator declares, "I expect account `0x...` to authorize this transaction according to scope `X`."

## Witnesses: Providing Authorization Proof

The `Witnesses` array provides the cryptographic proof corresponding to each `Signer`. For a transaction to be valid, there must typically be one witness for each signer, proving that the owner of the private key for that signer's account actually approved the transaction. Each `Witness` object has:

*   **`InvocationScript` (`byte[]`)**: Contains the *data* needed to satisfy the verification logic. For standard accounts, this is primarily the **cryptographic signature** (e.g., ECDSA signature) generated by signing the transaction data (excluding the witnesses themselves) with the account's private key. For multi-sig accounts, it contains multiple signatures. For custom contracts acting as witnesses, it might contain other parameters.
*   **`VerificationScript` (`byte[]`)**: Contains the *logic* (NeoVM bytecode) that verifies the `InvocationScript`.
    *   For **standard accounts**, this script is implicitly defined by the account's address (script hash). When executed, it typically pushes the account's public key onto the stack and calls the `CheckSig` opcode, which uses the signature from the `InvocationScript`.
    *   For **multi-sig accounts**, the script contains the logic to check multiple public keys against multiple signatures using `CheckMultiSig`.
    *   For **contracts acting as accounts/signers** (if `verify` method is implemented), this script *is* the contract's script hash, and executing the witness involves calling the contract's `verify()` method.

**How Verification Works:**

1.  A node processing the transaction iterates through the `Signers`.
2.  For each `Signer`, it finds the corresponding `Witness`.
3.  It executes the `Witness.VerificationScript` using the `Witness.InvocationScript` as input.
4.  If the `VerificationScript` executes successfully and returns `true` on the NeoVM stack, the witness is considered valid for that signer.
5.  If all witnesses are valid, the transaction proceeds to execute its main `Script`.

## `Runtime.CheckWitness()` in Smart Contracts

Inside your smart contract's method, you use `Runtime.CheckWitness(hashOrPubkey)` to verify authorization *at runtime*. This crucial function checks:

1.  Is the provided `hashOrPubkey` listed in the transaction's `Signers` array?
2.  Was a valid `Witness` provided for that `Signer`?
3.  Does the `Scope` defined for that `Signer` permit authorization in the *current* execution context (e.g., if `CalledByEntry` was used, does the signer match `Runtime.EntryScriptHash`)?

If all three conditions are met, `CheckWitness` returns `true`, confirming that the specified account legitimately authorized the action being performed *within the allowed scope*. This is the cornerstone of access control in Neo N3 smart contracts.

## Invoking Smart Contracts via Transactions (Refined Flow)

1.  **Construct Script:** A wallet/SDK creates a NeoVM script targeting your contract, usually calling `Contract.Call(yourContractHash, "methodName", arg1, ...)`.
2.  **Build Transaction:** This script is placed in the `Script` field of a transaction.
3.  **Define Signers:** The user's account (`userAccountHash`) is added to the `Signers` array, typically with `Scopes = WitnessScope.CalledByEntry`.
4.  **Set Fees & Other Fields:** Sufficient GAS, Nonce, `ValidUntilBlock`, etc., are set.
5.  **Sign:** The wallet uses the user's private key to sign the transaction data (excluding witnesses) creating a signature.
6.  **Add Witness:** A `Witness` is created:
    *   `InvocationScript`: Contains the signature.
    *   `VerificationScript`: Corresponds to the user's account type (e.g., standard single-sig verification).
    This Witness is added to the `Witnesses` array.
7.  **Broadcast:** The complete, signed transaction is sent to a Neo node.
8.  **Node Verification:** The node verifies all witnesses against the signers.
9.  **Execute Script:** If verification passes, the transaction `Script` (containing `Contract.Call`) is executed.
10. **`CheckWitness` Inside Contract:** When your contract's method executes `Runtime.CheckWitness(userAccountHash)`, the VM checks if `userAccountHash` was a verified signer with a scope allowing the current call (which `CalledByEntry` typically does if this is the first contract called).

Understanding this interplay between Signers (intent), Witnesses (proof), Scopes (context), and `Runtime.CheckWitness` (runtime verification) is crucial for designing and interacting with secure Neo N3 contracts.

[Previous: NeoVM & GAS](./01-neovm-gas.md) | [Next: Contract Structure](./03-contract-structure.md)