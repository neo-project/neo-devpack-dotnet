# Low-level IR (LIR) Design

Detailed reference for the Neo C# DevPack compiler’s LIR layer. Complements the overview in `docs/README-IR-Design-Neo.md` and the stack-focused notes in `docs/IR-LIR.md`.

---

## Purpose
- Represent programs in a target-close form that maps one-to-one to NeoVM opcodes and `SYSCALL`s, ready for NEF emission.
- Minimise peak stack height and stack shuffles while preserving the execution order of effectful operations and the intended control flow.
- Provide accurate resource metrics (peak stack, instruction count, code size, gas estimate) and robust structural verification.

---

## Two-phase Representation
- **VReg-LIR (value form, recommended):** virtual-register nodes (`VAdd`, `VGetItem`, `VSetItem`, `VConcat`, `VSlice`, `VSyscall`, …) with explicit use-def chains to enable last-mile algebraic cleanup and better scheduling.
- **Stack-LIR (final form):** concrete NeoVM-like opcodes with explicit stack effects, e.g.:
  - Constants: `PUSH0`, `PUSHM1`, `PUSHINT{8/16/32}`, `PUSHDATA{1/2/4}`, etc.
  - Stack operations: `DUP`, `OVER`, `SWAP`, `ROT`, `PICK`, `ROLL`, `NIP`, `TUCK`, `REVERSE n`.
  - Arithmetic/logic: `ADD`, `SUB`, `MUL`, `DIV`, `MOD`, `NEG`, `AND`, `OR`, `XOR`, `NOT`, `SHL`, `SHR`, `NUMEQUAL`, `NUMNOTEQUAL`, comparisons.
  - Containers/bytes: `NEWARRAY`, `NEWSTRUCT`, `NEWMAP`, `GETITEM`, `SETITEM`, `APPEND`, `PACK`, `UNPACK`, `LENGTH`, `CAT`, `SUBSTR`/`LEFT`/`RIGHT`, buffer ops.
  - Control flow & effects: `JMP`, `JMPIF`, `JMPIFNOT`, `CALL`, `RET`, `ABORT`, `SYSCALL`.

---

## Instruction Selection (MIR → VReg-LIR)
- Table-driven mapping:
  - Arithmetic/logic → `VAdd`, `VSub`, …
  - Array/Map/Struct accesses → `VGetItem`, `VSetItem`, `VPack`, `VExtract`, `VInsert`.
  - Byte/Buffer ops → `VCAT`, `VSUBSTR`, `VLENGTH`, `VBufferSet`, etc.
  - Syscalls → `VSyscall` with the final 4-byte id (hash per Neo N3 spec) and effect note for scheduling awareness.
- Fused patterns:
  - Compare + branch lowered to `NUMEQUAL`/`GT`/… feeding conditional jumps.
  - Constant aggregate initialisation mapped to specialised `PACK`/`NEWSTRUCT` forms.
- Guards already explicit in MIR (no hidden exceptions).

---

## Stack Scheduling (VReg-LIR → Stack-LIR)
- Objectives: minimise peak stack depth, minimise shuffles (`DUP`/`SWAP`/`PICK`/`ROLL`), and respect effects/order.
- Core algorithm:
  - Compute Sethi–Ullman numbers for expression DAGs; evaluate higher numbers first.
  - Exploit commutativity/associativity (e.g., `ADD`, `AND`, `OR`, `XOR`) to reduce swaps.
  - Maintain a stack model mapping vregs to slots; insert the cheapest shuffle sequence to align operands before each opcode.
  - Value reuse: `DUP`/`OVER` for near reuse; avoid deep `PICK` where possible—rewrite into `ROT`/`SWAP` chains when cheaper.
- Block interface & Phi elimination:
  - Define a block entry stack shape (often empty or a compact argument layout).
  - Eliminate Phi nodes by inserting parallel copies/shuffles on predecessor edges to establish the stack shape.
  - Ensure terminators leave the stack in an agreed shape (`RET` semantics consistent with emission conventions).

### Scheduler Implementation Blueprint

To reach production robustness the scheduler must be backed by a concrete evaluator loop. The implementation plan adopted in the compiler is:

1. **Static use counting** – walk every `VBlock`, collecting per-`VNode` use counts (Terminators and Phi inputs included). The remaining-use metric drives duplication versus consumption decisions so we never drop a value that still has outstanding uses.
2. **Explicit stack state** – track the evaluation stack as a list of `StackSlot { VNode? node, bool isReplica, bool isImmediate }`. Literal helpers (`EmitPushInt`, `EmitPushBytes`, …) append value slots; structural helpers (`EmitDup`, `EmitPick`, `EmitRoll`) update this model in lock-step with emitted instructions, keeping the simulated stack and the generated bytecode consistent.
3. **Operand preparation** – before emitting an opcode, build a per-instruction reservation map. For each operand in evaluation order:
   - If the remaining use count minus the already reserved uses is greater than one, duplicate the operand (`DUP` for depth 0, `PICK` with a pushed depth otherwise) so later instructions still have a copy available.
   - Otherwise rotate the real slot to the top via `ROLL` so the actual value is consumed. Guards set `forceDuplicate` so the original reference remains on stack even when the guard is the “last” use.
4. **Emission helpers** – all opcode helpers return the popped slots. Each non-immediate slot decrements its `VNode` use counter, preventing double-consumption and making “last use” checks exact. Result pushes tag the top slot with the produced `VNode`; a zero-use result is immediately removed via an explicit `DROP` to keep the stack contract tight.
5. **Control-flow handling** – terminators prepare their inputs (e.g., `RET` ensures the return value is on top) but otherwise rely on pre-scheduling block-shape alignment (Phi elimination and predecessor copy insertion). This keeps inter-block stack contracts explicit and verifiable.

This blueprint separates policy (ordering heuristics, hot-path layout) from mechanics (stack mutation), allowing future heuristics to evolve without rewriting the evaluator loop.

---

## Peephole Optimisation (Stack-LIR)
- Shuffle cancellation: remove `DUP; DROP`, `SWAP; SWAP`, `ROT; ROT; ROT`, etc.
- Algebraic identities: `PUSH0; ADD` → remove, `PUSH0; SUB` → remove, double negation, boolean double-not, small constant folding.
- Containers/bytes: fold fully constant `CAT`/`SUBSTR`, collapse repeated `GETITEM`/`LENGTH` on stable objects without intervening writes.
- Control flow cleanup: prefer fallthrough via condition inversion, remove jumps to immediate successor, thread jumps, drop empty blocks post-layout.

### NeoVM Primitive Mapping
- `VConvert` forms lower to specific NeoVM sequences: `ToBool` emits `NUMNOTEQUAL 0`, `ToByteString`/`ToBuffer` use the native `CONVERT` opcode with the appropriate `StackItemType`, and integer widen/narrow operations are treated as re-tags (NeoVM integers are arbitrary precision).
- `VBufferCopy` maps directly to `MEMCPY`, with operands ordered as `[destination, destinationOffset, source, sourceOffset, length]` before emission.
- `VStaticLoad`/`VStaticStore` materialise NeoVM static slot operations using `LDSFLD`/`STSFLD` (with 1-byte indices; quick forms may be substituted during emission). The scheduler treats static loads as side-effectful reads and will replay them in successor blocks when a value has been consumed.

---

## Block Layout & Branching
- Linearise hot paths (profile-guided if available, heuristics otherwise).
- Choose fallthrough for the more likely (or cheaper) branch, compact jump targets, reduce long-distance branches when encoding benefits.

---

## Encoding & Emission
- Constant encoding: pick shortest pushes (`PUSH0/M1`, `PUSHINT8/16/32`, `PUSHDATA{1/2/4}`) and reuse large constants with `DUP` when profitable.
- Syscalls: emit 4-byte ids; enforce whitelist; record gas hints.
- Static slots: choose the compact opcodes (`LDSFLD0`…`LDSFLD6`, `STSFLD0`…`STSFLD6`) whenever the slot index fits, falling back to the generic form only when necessary.
- Jumps: two-pass assembly—first place labels, then patch relative offsets and ensure encodability.
- NEF assembly: produce script with checksum, report size/peak stack, emit debug sourcemap (offset → source span).

---

## Verification & Metrics
- Stack simulation: track stack height per instruction, ensure no underflow, and validate exit stack shapes per convention.
- Control flow: ensure every block ends with a valid terminator, all labels resolve, no orphan blocks.
- Immediates: validate push widths, PUSHDATA lengths, branch targets/labels, and syscall identifier shape (4-byte payload).
- Metrics: report peak stack height, instruction count, code size, gas estimate (opcode table + syscall hints) per function and overall.

---

## Profiles & Heuristics
- **Debug:** minimal peepholes, conservative layout, maximum mapping fidelity, verbose sourcemaps.
- **Release-size:** peepholes favour shorter encodings, limit deep shuffles, reuse constants when size-effective.
- **Release-gas:** aggressive scheduling to reduce stack peaks and shuffles, hot-path layout, multi-round peepholes guided by cost.

---

## NeoVM-specific Notes
- Arbitrary-precision integer semantics: avoid width-dependent wraparound tricks; honour MIR’s checked arithmetic guarantees.
- `VCheckedArithmetic` lowers to the arithmetic opcode followed by a `WITHIN` range probe using the width hint; failure either branches to the designated block (`JMPIFNOT`) or triggers an `ASSERT`, ensuring C# `checked` semantics survive to bytecode.
- `ByteString` vs `Buffer`: ByteStrings are immutable, Buffer operations are explicit (`BufferNew/Set/Copy`).
- Container semantics map directly to `NEWARRAY`, `NEWSTRUCT`, `NEWMAP`, `GETITEM`, `SETITEM`, etc.
- Guard failures from MIR map to `ABORT` (or equivalent terminal sequences) when `onFail = Abort`.

---

## Testing Guidance
- Stack-safety fuzzing: generate random small DAGs/CFGs, ensure stack invariants and exit shapes hold.
- Golden Stack-LIR dumps and emitted NEF bytes for curated samples; review diffs over time.
- Differential testing against neon/NeoVM emulator outputs on representative DevPack programs.
