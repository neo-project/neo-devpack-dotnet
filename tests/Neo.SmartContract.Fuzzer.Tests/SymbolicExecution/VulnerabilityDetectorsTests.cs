using Microsoft.VisualStudio.TestTools.UnitTesting;
using Neo.SmartContract.Fuzzer.SymbolicExecution;
using Neo.SmartContract.Fuzzer.SymbolicExecution.Types;
using Neo.VM;
using System.Collections.Generic;
using System.Linq;
using FluentAssertions;

namespace Neo.SmartContract.Fuzzer.Tests.SymbolicExecution
{
    [TestClass]
    public class VulnerabilityDetectorsTests
    {
        [TestClass]
        public class IntegerOverflowDetectorTests
        {
            private IntegerOverflowDetector _detector;

            [TestInitialize]
            public void Setup()
            {
                _detector = new IntegerOverflowDetector();
            }

            [TestMethod]
            public void Name_ReturnsCorrectValue()
            {
                // Act
                string name = _detector.Name;

                // Assert
                name.Should().Be("Integer Overflow Detector");
            }

            [TestMethod]
            public void Description_ReturnsCorrectValue()
            {
                // Act
                string description = _detector.Description;

                // Assert
                description.Should().Contain("integer overflow");
            }

            [TestMethod]
            public void DetectVulnerabilities_ArithmeticOperation_ReturnsVulnerability()
            {
                // Arrange
                var x = new SymbolicVariable("x", "Integer");
                var y = new SymbolicVariable("y", "Integer");
                var binaryExpr = new SymbolicBinaryExpression(x, y, "+", "Integer");
                var path = new ExecutionPath
                {
                    PathConstraints = new List<PathConstraint>
                    {
                        new PathConstraint(binaryExpr, false)
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().NotBeEmpty();
                vulnerabilities.First().Type.Should().Be("Integer Overflow");
                vulnerabilities.First().Severity.Should().Be(VulnerabilitySeverity.High);
            }

            [TestMethod]
            public void DetectVulnerabilities_NonArithmeticOperation_ReturnsNoVulnerability()
            {
                // Arrange
                var x = new SymbolicVariable("x", "Integer");
                var y = new SymbolicVariable("y", "Integer");
                var binaryExpr = new SymbolicBinaryExpression(x, y, "==", "Boolean");
                var path = new ExecutionPath
                {
                    PathConstraints = new List<PathConstraint>
                    {
                        new PathConstraint(binaryExpr, false)
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().BeEmpty();
            }
        }

        [TestClass]
        public class DivisionByZeroDetectorTests
        {
            private DivisionByZeroDetector _detector;

            [TestInitialize]
            public void Setup()
            {
                _detector = new DivisionByZeroDetector();
            }

            [TestMethod]
            public void Name_ReturnsCorrectValue()
            {
                // Act
                string name = _detector.Name;

                // Assert
                name.Should().Be("Division by Zero Detector");
            }

            [TestMethod]
            public void Description_ReturnsCorrectValue()
            {
                // Act
                string description = _detector.Description;

                // Assert
                description.Should().Contain("division by zero");
            }

            [TestMethod]
            public void DetectVulnerabilities_DivisionOperation_ReturnsVulnerability()
            {
                // Arrange
                var x = new SymbolicVariable("x", "Integer");
                var zero = new SymbolicConstant(0, "Integer");
                var binaryExpr = new SymbolicBinaryExpression(x, zero, "/", "Integer");
                var path = new ExecutionPath
                {
                    PathConstraints = new List<PathConstraint>
                    {
                        new PathConstraint(binaryExpr, false)
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().NotBeEmpty();
                vulnerabilities.First().Type.Should().Be("Division by Zero");
                vulnerabilities.First().Severity.Should().Be(VulnerabilitySeverity.High);
            }

            [TestMethod]
            public void DetectVulnerabilities_ModuloOperation_ReturnsVulnerability()
            {
                // Arrange
                var x = new SymbolicVariable("x", "Integer");
                var zero = new SymbolicConstant(0, "Integer");
                var binaryExpr = new SymbolicBinaryExpression(x, zero, "%", "Integer");
                var path = new ExecutionPath
                {
                    PathConstraints = new List<PathConstraint>
                    {
                        new PathConstraint(binaryExpr, false)
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().NotBeEmpty();
                vulnerabilities.First().Type.Should().Be("Division by Zero");
                vulnerabilities.First().Severity.Should().Be(VulnerabilitySeverity.High);
            }

            [TestMethod]
            public void DetectVulnerabilities_NonDivisionOperation_ReturnsNoVulnerability()
            {
                // Arrange
                var x = new SymbolicVariable("x", "Integer");
                var y = new SymbolicVariable("y", "Integer");
                var binaryExpr = new SymbolicBinaryExpression(x, y, "+", "Integer");
                var path = new ExecutionPath
                {
                    PathConstraints = new List<PathConstraint>
                    {
                        new PathConstraint(binaryExpr, false)
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().BeEmpty();
            }
        }

        [TestClass]
        public class UnauthorizedAccessDetectorTests
        {
            private UnauthorizedAccessDetector _detector;

            [TestInitialize]
            public void Setup()
            {
                _detector = new UnauthorizedAccessDetector();
            }

            [TestMethod]
            public void Name_ReturnsCorrectValue()
            {
                // Act
                string name = _detector.Name;

                // Assert
                name.Should().Be("Unauthorized Access Detector");
            }

            [TestMethod]
            public void Description_ReturnsCorrectValue()
            {
                // Act
                string description = _detector.Description;

                // Assert
                description.Should().Contain("unauthorized access");
            }

            [TestMethod]
            public void DetectVulnerabilities_StorageChangesWithoutWitnessCheck_ReturnsVulnerability()
            {
                // Arrange
                var path = new ExecutionPath
                {
                    StorageChanges = new Dictionary<byte[], byte[]>(ByteArrayEqualityComparer.Default)
                    {
                        { new byte[] { 1, 2, 3 }, new byte[] { 4, 5, 6 } }
                    },
                    Events = new List<string>() // No witness check events
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().NotBeEmpty();
                vulnerabilities.First().Type.Should().Be("Missing Witness Check");
                vulnerabilities.First().Severity.Should().Be(VulnerabilitySeverity.High);
            }

            [TestMethod]
            public void DetectVulnerabilities_StorageChangesWithWitnessCheck_ReturnsNoVulnerability()
            {
                // Arrange
                var path = new ExecutionPath
                {
                    StorageChanges = new Dictionary<byte[], byte[]>(ByteArrayEqualityComparer.Default)
                    {
                        { new byte[] { 1, 2, 3 }, new byte[] { 4, 5, 6 } }
                    },
                    Events = new List<string> { "CheckWitness" }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().BeEmpty();
            }

            [TestMethod]
            public void DetectVulnerabilities_NoStorageChanges_ReturnsNoVulnerability()
            {
                // Arrange
                var path = new ExecutionPath
                {
                    StorageChanges = new Dictionary<byte[], byte[]>(ByteArrayEqualityComparer.Default)(),
                    Events = new List<string>() // No witness check events
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().BeEmpty();
            }
        }

        [TestClass]
        public class StorageExhaustionDetectorTests
        {
            private StorageExhaustionDetector _detector;

            [TestInitialize]
            public void Setup()
            {
                _detector = new StorageExhaustionDetector();
            }

            [TestMethod]
            public void Name_ReturnsCorrectValue()
            {
                // Act
                string name = _detector.Name;

                // Assert
                name.Should().Be("Storage Exhaustion Detector");
            }

            [TestMethod]
            public void Description_ReturnsCorrectValue()
            {
                // Act
                string description = _detector.Description;

                // Assert
                description.Should().Contain("storage exhaustion");
            }

            [TestMethod]
            public void DetectVulnerabilities_LargeStorageKey_ReturnsVulnerability()
            {
                // Arrange
                var largeKey = new byte[65]; // 65 bytes is larger than the 64-byte threshold
                var path = new ExecutionPath
                {
                    StorageChanges = new Dictionary<byte[], byte[]>(ByteArrayEqualityComparer.Default)
                    {
                        { largeKey, new byte[] { 1, 2, 3 } }
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().NotBeEmpty();
                vulnerabilities.Should().Contain(v => v.Type == "Large Storage Key");
                vulnerabilities.First().Severity.Should().Be(VulnerabilitySeverity.Medium);
            }

            [TestMethod]
            public void DetectVulnerabilities_LargeStorageValue_ReturnsVulnerability()
            {
                // Arrange
                var largeValue = new byte[1025]; // 1025 bytes is larger than the 1024-byte threshold
                var path = new ExecutionPath
                {
                    StorageChanges = new Dictionary<byte[], byte[]>(ByteArrayEqualityComparer.Default)
                    {
                        { new byte[] { 1, 2, 3 }, largeValue }
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().NotBeEmpty();
                vulnerabilities.Should().Contain(v => v.Type == "Large Storage Value");
                vulnerabilities.First().Severity.Should().Be(VulnerabilitySeverity.Medium);
            }

            [TestMethod]
            public void DetectVulnerabilities_ManyStorageOperations_ReturnsVulnerability()
            {
                // Arrange
                var path = new ExecutionPath
                {
                    StorageChanges = new Dictionary<byte[], byte[]>(ByteArrayEqualityComparer.Default)()
                };

                // Add 11 storage changes (more than the threshold of 10)
                for (int i = 0; i < 11; i++)
                {
                    path.StorageChanges.Add(new byte[] { (byte)i }, new byte[] { (byte)(i + 100) });
                }

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().NotBeEmpty();
                vulnerabilities.Should().Contain(v => v.Type == "Many Storage Operations");
                vulnerabilities.Should().Contain(v => v.Severity == VulnerabilitySeverity.Low);
            }

            [TestMethod]
            public void DetectVulnerabilities_NormalStorage_ReturnsNoVulnerability()
            {
                // Arrange
                var path = new ExecutionPath
                {
                    StorageChanges = new Dictionary<byte[], byte[]>(ByteArrayEqualityComparer.Default)
                    {
                        { new byte[] { 1, 2, 3 }, new byte[] { 4, 5, 6 } }
                    }
                };

                // Act
                var vulnerabilities = _detector.DetectVulnerabilities(path);

                // Assert
                vulnerabilities.Should().BeEmpty();
            }
        }
    }
}
