using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Neo.SmartContract.Fuzzer.Vulnerabilities;
using Neo.SmartContract.Manifest;
using Neo.VM.Types;
using Xunit;

namespace Neo.SmartContract.Fuzzer.Tests.Vulnerabilities
{
    /// <summary>
    /// Tests for the VulnerabilityDetector class
    /// </summary>
    public class VulnerabilityDetectorTests
    {
        private readonly string _testDataPath = Path.Combine("TestData");
        private readonly string _manifestPath;
        private readonly FuzzerConfiguration _config;

        /// <summary>
        /// Initialize test data
        /// </summary>
        public VulnerabilityDetectorTests()
        {
            _manifestPath = Path.Combine(_testDataPath, "SampleToken.manifest.json");
            _config = new FuzzerConfiguration
            {
                EnableVulnerabilityDetection = true,
                MinimumVulnerabilitySeverity = "Low",
                MinimumVulnerabilityConfidence = "Low"
            };
        }

        /// <summary>
        /// Test detection of integer overflow/underflow vulnerabilities
        /// </summary>
        [Fact]
        public void IntegerOverflowUnderflowDetectionTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results with arithmetic errors
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(long.MaxValue) },
                    Success = false,
                    ErrorMessage = "arithmetic operation overflow"
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(long.MaxValue - 1) },
                    Success = false,
                    ErrorMessage = "arithmetic operation overflow"
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(long.MinValue) },
                    Success = false,
                    ErrorMessage = "arithmetic operation underflow"
                },
                // Add some successful executions
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(100) },
                    Success = true
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(200) },
                    Success = true
                }
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, _config);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Check for integer overflow/underflow vulnerability
            var integerVulnerability = vulnerabilities.FirstOrDefault(v => v.Category == VulnerabilityCategory.IntegerOverflowUnderflow);
            Assert.NotNull(integerVulnerability);
            Assert.Equal("transfer", integerVulnerability.MethodName);
            Assert.Contains("overflow", integerVulnerability.Description);
        }

        /// <summary>
        /// Test detection of reentrancy vulnerabilities
        /// </summary>
        [Fact]
        public void ReentrancyDetectionTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results for methods that might have reentrancy vulnerabilities
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(100) },
                    Success = true
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(200) },
                    Success = true
                }
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, _config);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Check for reentrancy vulnerability
            var reentrancyVulnerability = vulnerabilities.FirstOrDefault(v => v.Category == VulnerabilityCategory.Reentrancy);
            Assert.NotNull(reentrancyVulnerability);
            Assert.Equal("transfer", reentrancyVulnerability.MethodName);
            Assert.Contains("reentrancy", reentrancyVulnerability.Description.ToLower());
        }

        /// <summary>
        /// Test detection of unauthorized access vulnerabilities
        /// </summary>
        [Fact]
        public void UnauthorizedAccessDetectionTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results for sensitive methods
                new ExecutionResult
                {
                    MethodName = "update",
                    Parameters = new StackItem[] { new ByteArray(new byte[20]), new ByteString("test") },
                    Success = true
                },
                new ExecutionResult
                {
                    MethodName = "destroy",
                    Parameters = Array.Empty<StackItem>(),
                    Success = true
                }
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, _config);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Check for unauthorized access vulnerabilities
            var updateVulnerability = vulnerabilities.FirstOrDefault(v => 
                v.Category == VulnerabilityCategory.UnauthorizedAccess && v.MethodName == "update");
            Assert.NotNull(updateVulnerability);
            
            var destroyVulnerability = vulnerabilities.FirstOrDefault(v => 
                v.Category == VulnerabilityCategory.UnauthorizedAccess && v.MethodName == "destroy");
            Assert.NotNull(destroyVulnerability);
        }

        /// <summary>
        /// Test detection of improper exception handling vulnerabilities
        /// </summary>
        [Fact]
        public void ImproperExceptionHandlingDetectionTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results with diverse error messages
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(100) },
                    Success = false,
                    ErrorMessage = "Invalid sender"
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(200) },
                    Success = false,
                    ErrorMessage = "Invalid recipient"
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(300) },
                    Success = false,
                    ErrorMessage = "Insufficient balance"
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(400) },
                    Success = false,
                    ErrorMessage = "Invalid amount"
                }
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, _config);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Check for improper exception handling vulnerability
            var exceptionVulnerability = vulnerabilities.FirstOrDefault(v => v.Category == VulnerabilityCategory.ImproperExceptionHandling);
            Assert.NotNull(exceptionVulnerability);
            Assert.Equal("transfer", exceptionVulnerability.MethodName);
            Assert.Contains("error message", exceptionVulnerability.Description.ToLower());
        }

        /// <summary>
        /// Test detection of gas-related vulnerabilities
        /// </summary>
        [Fact]
        public void GasRelatedVulnerabilityDetectionTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results with high gas consumption
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(100) },
                    Success = true,
                    GasConsumed = 15000000 // High gas consumption
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(200) },
                    Success = true,
                    GasConsumed = 12000000 // High gas consumption
                },
                // Add out of gas error
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(300) },
                    Success = false,
                    ErrorMessage = "gas limit exceeded"
                }
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, _config);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Check for gas-related vulnerability
            var gasVulnerability = vulnerabilities.FirstOrDefault(v => v.Category == VulnerabilityCategory.GasRelated);
            Assert.NotNull(gasVulnerability);
            Assert.Equal("transfer", gasVulnerability.MethodName);
            Assert.Contains("gas", gasVulnerability.Description.ToLower());
        }

        /// <summary>
        /// Test detection of logic vulnerabilities
        /// </summary>
        [Fact]
        public void LogicVulnerabilityDetectionTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            // Create parameters that will be serialized to the same string
            var senderBytes = new byte[20];
            var recipientBytes = new byte[20];
            var amount = new Integer(100);
            
            var results = new List<ExecutionResult>
            {
                // Create results with inconsistent behavior for the same inputs
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(senderBytes), new ByteString(recipientBytes), amount },
                    Success = true
                },
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(senderBytes), new ByteString(recipientBytes), amount },
                    Success = false,
                    ErrorMessage = "Transaction failed"
                }
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, _config);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Check for logic vulnerability
            var logicVulnerability = vulnerabilities.FirstOrDefault(v => v.Category == VulnerabilityCategory.LogicVulnerability);
            Assert.NotNull(logicVulnerability);
            Assert.Equal("transfer", logicVulnerability.MethodName);
            Assert.Contains("inconsistent", logicVulnerability.Description.ToLower());
        }

        /// <summary>
        /// Test that no vulnerabilities are detected when there are none
        /// </summary>
        [Fact]
        public void NoVulnerabilitiesDetectionTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results with consistent successful executions
                new ExecutionResult
                {
                    MethodName = "balanceOf",
                    Parameters = new StackItem[] { new ByteString(new byte[20]) },
                    Success = true,
                    GasConsumed = 1000
                },
                new ExecutionResult
                {
                    MethodName = "balanceOf",
                    Parameters = new StackItem[] { new ByteString(new byte[20]) },
                    Success = true,
                    GasConsumed = 1100
                }
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, _config);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.Empty(vulnerabilities.Where(v => v.MethodName == "balanceOf"));
        }

        /// <summary>
        /// Test filtering vulnerabilities by severity
        /// </summary>
        [Fact]
        public void VulnerabilityFilteringBySeverityTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results that would trigger vulnerabilities of different severities
                new ExecutionResult
                {
                    MethodName = "update",
                    Parameters = new StackItem[] { new ByteArray(new byte[20]), new ByteString("test") },
                    Success = true
                }, // Critical severity (unauthorized access)
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(long.MaxValue) },
                    Success = false,
                    ErrorMessage = "arithmetic operation overflow"
                } // Medium severity (integer overflow)
            };
            
            // Configure to only detect Critical vulnerabilities
            var highSeverityConfig = new FuzzerConfiguration
            {
                EnableVulnerabilityDetection = true,
                MinimumVulnerabilitySeverity = "Critical",
                MinimumVulnerabilityConfidence = "Low"
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, highSeverityConfig);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Should only contain Critical vulnerabilities
            Assert.All(vulnerabilities, v => Assert.Equal(VulnerabilitySeverity.Critical, v.Severity));
            
            // Should contain the unauthorized access vulnerability
            Assert.Contains(vulnerabilities, v => 
                v.Category == VulnerabilityCategory.UnauthorizedAccess && v.MethodName == "update");
            
            // Should not contain the integer overflow vulnerability
            Assert.DoesNotContain(vulnerabilities, v => 
                v.Category == VulnerabilityCategory.IntegerOverflowUnderflow);
        }

        /// <summary>
        /// Test filtering vulnerabilities by confidence level
        /// </summary>
        [Fact]
        public void VulnerabilityFilteringByConfidenceTest()
        {
            // Arrange
            var manifestJson = File.ReadAllText(_manifestPath);
            var manifest = ContractManifest.Parse(manifestJson);
            
            var results = new List<ExecutionResult>
            {
                // Create results that would trigger vulnerabilities with different confidence levels
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(100) },
                    Success = true
                } // Low confidence (reentrancy)
            };
            
            // Configure to only detect High confidence vulnerabilities
            var highConfidenceConfig = new FuzzerConfiguration
            {
                EnableVulnerabilityDetection = true,
                MinimumVulnerabilitySeverity = "Low",
                MinimumVulnerabilityConfidence = "High"
            };
            
            // Act
            var detector = new VulnerabilityDetector(results, manifest.Abi.Methods, highConfidenceConfig);
            var vulnerabilities = detector.DetectVulnerabilities();
            
            // Assert
            // Should not contain the reentrancy vulnerability (which has Low confidence)
            Assert.DoesNotContain(vulnerabilities, v => 
                v.Category == VulnerabilityCategory.Reentrancy && v.Confidence == ConfidenceLevel.Low);
        }
    }
}