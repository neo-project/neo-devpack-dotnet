using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Neo.SmartContract.Fuzzer.Vulnerabilities;
using Neo.SmartContract.Manifest;
using Neo.VM.Types;
using Xunit;

namespace Neo.SmartContract.Fuzzer.Tests.Vulnerabilities
{
    /// <summary>
    /// Tests for the VulnerabilityAnalyzer class
    /// </summary>
    public class VulnerabilityAnalyzerTests
    {
        private readonly string _testDataPath = Path.Combine("TestData");
        private readonly string _manifestPath;
        private readonly FuzzerConfiguration _config;
        private readonly List<ExecutionResult> _results;
        private readonly ContractMethodDescriptor[] _methods;

        /// <summary>
        /// Initialize test data
        /// </summary>
        public VulnerabilityAnalyzerTests()
        {
            _manifestPath = Path.Combine(_testDataPath, "SampleToken.manifest.json");
            _config = new FuzzerConfiguration
            {
                EnableVulnerabilityDetection = true,
                MinimumVulnerabilitySeverity = "Low",
                MinimumVulnerabilityConfidence = "Low"
            };
            
            // Create test execution results
            _results = new List<ExecutionResult>
            {
                // Integer overflow
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(long.MaxValue) },
                    Success = false,
                    ErrorMessage = "arithmetic operation overflow"
                },
                // Unauthorized access
                new ExecutionResult
                {
                    MethodName = "update",
                    Parameters = new StackItem[] { new ByteArray(new byte[20]), new ByteString("test") },
                    Success = true
                },
                // High gas consumption
                new ExecutionResult
                {
                    MethodName = "transfer",
                    Parameters = new StackItem[] { new ByteString(new byte[20]), new ByteString(new byte[20]), new Integer(100) },
                    Success = true,
                    GasConsumed = 15000000
                },
                // Successful execution
                new ExecutionResult
                {
                    MethodName = "balanceOf",
                    Parameters = new StackItem[] { new ByteString(new byte[20]) },
                    Success = true,
                    GasConsumed = 1000
                }
            };
            
            // Load contract manifest
            var manifestJson = File.ReadAllText(_manifestPath);
            _methods = ContractManifest.Parse(manifestJson).Abi.Methods;
        }

        /// <summary>
        /// Test analyzing a contract for vulnerabilities
        /// </summary>
        [Fact]
        public void AnalyzeContractTest()
        {
            // Arrange
            var analyzer = new VulnerabilityAnalyzer("SampleToken", _results, _methods, _config);
            
            // Act
            var vulnerabilities = analyzer.AnalyzeContract();
            
            // Assert
            Assert.NotEmpty(vulnerabilities);
            
            // Should detect multiple types of vulnerabilities
            Assert.Contains(vulnerabilities, v => v.Category == VulnerabilityCategory.IntegerOverflowUnderflow);
            Assert.Contains(vulnerabilities, v => v.Category == VulnerabilityCategory.UnauthorizedAccess);
            Assert.Contains(vulnerabilities, v => v.Category == VulnerabilityCategory.GasRelated);
        }

        /// <summary>
        /// Test getting vulnerability counts
        /// </summary>
        [Fact]
        public void GetVulnerabilityCountsTest()
        {
            // Arrange
            var analyzer = new VulnerabilityAnalyzer("SampleToken", _results, _methods, _config);
            analyzer.AnalyzeContract();
            
            // Act
            int totalCount = analyzer.GetVulnerabilityCount();
            var countBySeverity = analyzer.GetVulnerabilityCountBySeverity();
            var countByCategory = analyzer.GetVulnerabilityCountByCategory();
            
            // Assert
            Assert.True(totalCount > 0);
            Assert.NotEmpty(countBySeverity);
            Assert.NotEmpty(countByCategory);
            
            // Sum of counts by severity should equal total count
            Assert.Equal(totalCount, countBySeverity.Values.Sum());
            
            // Sum of counts by category should equal total count
            Assert.Equal(totalCount, countByCategory.Values.Sum());
        }

        /// <summary>
        /// Test getting vulnerabilities for a specific method
        /// </summary>
        [Fact]
        public void GetVulnerabilitiesForMethodTest()
        {
            // Arrange
            var analyzer = new VulnerabilityAnalyzer("SampleToken", _results, _methods, _config);
            analyzer.AnalyzeContract();
            
            // Act
            var transferVulnerabilities = analyzer.GetVulnerabilitiesForMethod("transfer");
            var updateVulnerabilities = analyzer.GetVulnerabilitiesForMethod("update");
            var balanceOfVulnerabilities = analyzer.GetVulnerabilitiesForMethod("balanceOf");
            
            // Assert
            Assert.NotEmpty(transferVulnerabilities);
            Assert.NotEmpty(updateVulnerabilities);
            Assert.Empty(balanceOfVulnerabilities);
            
            // Transfer method should have integer overflow and gas-related vulnerabilities
            Assert.Contains(transferVulnerabilities, v => v.Category == VulnerabilityCategory.IntegerOverflowUnderflow);
            Assert.Contains(transferVulnerabilities, v => v.Category == VulnerabilityCategory.GasRelated);
            
            // Update method should have unauthorized access vulnerability
            Assert.Contains(updateVulnerabilities, v => v.Category == VulnerabilityCategory.UnauthorizedAccess);
        }

        /// <summary>
        /// Test generating a Markdown report
        /// </summary>
        [Fact]
        public void GenerateMarkdownReportTest()
        {
            // Arrange
            var analyzer = new VulnerabilityAnalyzer("SampleToken", _results, _methods, _config);
            analyzer.AnalyzeContract();
            
            // Act
            string report = analyzer.GenerateMarkdownReport();
            
            // Assert
            Assert.NotNull(report);
            Assert.NotEmpty(report);
            
            // Report should contain vulnerability analysis section
            Assert.Contains("## Vulnerability Analysis", report);
            
            // Report should contain summary section
            Assert.Contains("### Summary", report);
            
            // Report should contain detailed vulnerabilities section
            Assert.Contains("### Detailed Vulnerabilities", report);
            
            // Report should contain overall recommendations section
            Assert.Contains("### Overall Recommendations", report);
            
            // Report should mention detected vulnerabilities
            Assert.Contains("IntegerOverflowUnderflow", report);
            Assert.Contains("UnauthorizedAccess", report);
            Assert.Contains("GasRelated", report);
        }

        /// <summary>
        /// Test generating a JSON report
        /// </summary>
        [Fact]
        public void GenerateJsonReportTest()
        {
            // Arrange
            var analyzer = new VulnerabilityAnalyzer("SampleToken", _results, _methods, _config);
            analyzer.AnalyzeContract();
            
            // Act
            string report = analyzer.GenerateJsonReport();
            
            // Assert
            Assert.NotNull(report);
            Assert.NotEmpty(report);
            
            // Report should be valid JSON
            var exception = Record.Exception(() => System.Text.Json.JsonDocument.Parse(report));
            Assert.Null(exception);
            
            // Report should contain contract name
            Assert.Contains("\"ContractName\": \"SampleToken\"", report);
            
            // Report should contain vulnerability counts
            Assert.Contains("\"TotalVulnerabilities\":", report);
            Assert.Contains("\"SeverityCounts\":", report);
            Assert.Contains("\"CategoryCounts\":", report);
            
            // Report should contain vulnerabilities array
            Assert.Contains("\"Vulnerabilities\":", report);
            
            // Report should mention detected vulnerabilities
            Assert.Contains("IntegerOverflowUnderflow", report);
            Assert.Contains("UnauthorizedAccess", report);
            Assert.Contains("GasRelated", report);
        }

        /// <summary>
        /// Test generating an HTML report
        /// </summary>
        [Fact]
        public void GenerateHtmlReportTest()
        {
            // Arrange
            var analyzer = new VulnerabilityAnalyzer("SampleToken", _results, _methods, _config);
            analyzer.AnalyzeContract();
            
            // Act
            string report = analyzer.GenerateHtmlReport();
            
            // Assert
            Assert.NotNull(report);
            Assert.NotEmpty(report);
            
            // Report should contain HTML elements
            Assert.Contains("<h2>Vulnerability Analysis</h2>", report);
            
            // Report should contain summary section
            Assert.Contains("<h3>Summary</h3>", report);
            
            // Report should contain detailed vulnerabilities section
            Assert.Contains("<h3>Detailed Vulnerabilities</h3>", report);
            
            // Report should contain overall recommendations section
            Assert.Contains("<h3>Overall Recommendations</h3>", report);
            
            // Report should mention detected vulnerabilities
            Assert.Contains("IntegerOverflowUnderflow", report);
            Assert.Contains("UnauthorizedAccess", report);
            Assert.Contains("GasRelated", report);
        }

        /// <summary>
        /// Test that no vulnerabilities are reported when vulnerability detection is disabled
        /// </summary>
        [Fact]
        public void DisabledVulnerabilityDetectionTest()
        {
            // Arrange
            var disabledConfig = new FuzzerConfiguration
            {
                EnableVulnerabilityDetection = false
            };
            
            var analyzer = new VulnerabilityAnalyzer("SampleToken", _results, _methods, disabledConfig);
            
            // Act
            var vulnerabilities = analyzer.AnalyzeContract();
            
            // Assert
            Assert.Empty(vulnerabilities);
            
            // Reports should indicate no vulnerabilities
            string markdownReport = analyzer.GenerateMarkdownReport();
            Assert.Contains("No vulnerabilities detected", markdownReport);
            
            string htmlReport = analyzer.GenerateHtmlReport();
            Assert.Contains("No vulnerabilities detected", htmlReport);
        }

        /// <summary>
        /// Test handling of null or empty inputs
        /// </summary>
        [Fact]
        public void NullOrEmptyInputsTest()
        {
            // Arrange & Act & Assert
            
            // Null contract name
            Assert.Throws<ArgumentNullException>(() => new VulnerabilityAnalyzer(null, _results, _methods, _config));
            
            // Null execution results
            Assert.Throws<ArgumentNullException>(() => new VulnerabilityAnalyzer("SampleToken", null, _methods, _config));
            
            // Null methods
            Assert.Throws<ArgumentNullException>(() => new VulnerabilityAnalyzer("SampleToken", _results, null, _config));
            
            // Null configuration
            Assert.Throws<ArgumentNullException>(() => new VulnerabilityAnalyzer("SampleToken", _results, _methods, null));
            
            // Empty execution results
            var emptyResults = new List<ExecutionResult>();
            var analyzer = new VulnerabilityAnalyzer("SampleToken", emptyResults, _methods, _config);
            var vulnerabilities = analyzer.AnalyzeContract();
            Assert.Empty(vulnerabilities);
        }
    }
}